<title>Игорь & Анна</title>

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
	html,
	body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
		touch-action: none;
		user-select: none;
	}

	html {
		overflow: hidden;
		/* background: #c9d9d1; */
		background-image: linear-gradient(
			159deg,
			rgb(228, 236, 232) 0%,
			rgb(220, 231, 226) 35%,
			rgb(201, 217, 209) 64%,
			rgb(127, 164, 145) 100%
		);
	}

	body {
		/* background-image: repeating-conic-gradient(hsla(0, 0%, 100%, 0.1) 0 15deg, hsla(0, 0%, 100%, 0) 0 30deg); */
	}

	lume-scene {
		position: absolute;
		top: 0;
		left: 0;
	}

	.rays {
		position: absolute;
		top: -140%;
		left: -140%;
		width: 250%;
		height: 250%;
		pointer-events: none;

		background-image: repeating-conic-gradient(hsla(0, 0%, 100%, 0.3) 0 5deg, hsla(0, 0%, 100%, 0) 0 15deg);
	}

	#fitted {
		background: #fbfaf4;
	}

	img,
	div {
		width: 100%;
		height: 100%;
		display: block;
	}

	div {
		overflow: hidden;
	}
	img {
		transform: scale(1.01);
	}

	.particle {
		/* background-color: #8db497; */
		/* border-radius: 100%; */
		/* border: 0.5px solid teal; */
	}

	.star {
		width: 100%;
		height: 100%;
		display: block;
		fill: #8db497;
	}
</style>

<body touch-action="none">
	<!-- <script src="../../dist/global.js"></script> -->
	<script src="https://unpkg.com/lume@0.3.0-alpha.7/dist/global.js"></script>
	<script>
		// Define all the LUME elements with their default names.
		LUME.useDefaultNames()
	</script>

	<lume-scene id="scene" perspective="800" webgl>
		<lume-ambient-light color="white" intensity="0.6"></lume-ambient-light>

		<lume-point-light
			id="light"
			position="0 0 400"
			intensity="0.6"
			color="white"
			shadow-radius="2"
			shadow-bias="-0.002"
		></lume-point-light>

		<lume-node
			id="fitter"
			size-mode="proportional proportional"
			size="0.9 0.9"
			align-point="0.5 0.5"
			mount-point="0.5 0.5"
		>
			<lume-mixed-plane id="fitted" align-point="0.5 0.5" mount-point="0.5 0.5" size="647 1150" color="#444">
				<lume-node size-mode="proportional proportional" size="1 1" position="0 0 75">
					<div>
						<img src="https://assets.codepen.io/191583/background-01.png" />
					</div>
				</lume-node>
				<lume-node size-mode="proportional proportional" size="1 1" position="0 0 60">
					<div>
						<img src="https://assets.codepen.io/191583/text-01.2.svg" />
					</div>
				</lume-node>
				<lume-node size-mode="proportional proportional" size="1 1" position="0 0 90">
					<div>
						<img src="https://assets.codepen.io/191583/anna.svg" />
					</div>
				</lume-node>
				<lume-node size-mode="proportional proportional" size="1 1" position="0 0 60">
					<div>
						<img src="https://assets.codepen.io/191583/and.svg" />
					</div>
				</lume-node>
				<lume-node size-mode="proportional proportional" size="1 1" position="0 0 90">
					<div>
						<img src="https://assets.codepen.io/191583/igor.svg" />
					</div>
				</lume-node>
				<lume-node size-mode="proportional proportional" size="1 1" position="0 0 75">
					<div>
						<img src="https://assets.codepen.io/191583/numbers.svg" />
					</div>
				</lume-node>
			</lume-mixed-plane>
		</lume-node>

		<lume-node id="particleContainer" align-point="0.5 0.5" rotation="0 0 0"></lume-node>
	</lume-scene>

	<div class="rays"></div>

	<script>
		const {autorun, variable, untrack, Motor} = LUME

		fitted.three.material.opacity = 0.3

		///// FIT CARD IN VIEWPORT /////////////////////////////////////////

		//////// SCALE MODE ///////////////////////////////////

		// let queued = null

		// autorun(() => {
		// 	// fitter.calculatedSize
		// 	// fitted.calculatedSize
		// 	// if (queued) return
		// 	// queued = Promise.resolve().then(() => {
		// 	// 	queued = null

		// 	const outerAspect = fitter.calculatedSize.x / fitter.calculatedSize.y
		// 	const innerAspect = fitted.calculatedSize.x / fitted.calculatedSize.y

		// 	let ratio = 1

		// 	if (innerAspect <= outerAspect) {
		// 		// inner should fit vertically
		// 		const outerSize = fitter.calculatedSize.y
		// 		const innerSize = fitted.calculatedSize.y

		// 		ratio = outerSize / innerSize
		// 	} else {
		// 		// inner should fit horizontally
		// 		const outerSize = fitter.calculatedSize.x
		// 		const innerSize = fitted.calculatedSize.x

		// 		ratio = outerSize / innerSize
		// 	}

		// 	fitted.scale = [ratio, ratio]

		// 	// })
		// })

		//////// RESIZE MODE ///////////////////////////////////

		// Requires literal sizing
		// Use a given aspect, or calculate it based on initial size.
		const innerSize = fitted.size
		const innerAspect = innerSize.x / innerSize.y

		const outerAspect = variable(1)
		autorun(() => outerAspect(fitter.calculatedSize.x / fitter.calculatedSize.y))

		autorun(() => {
			// const outerAspect = fitter.calculatedSize.x / fitter.calculatedSize.y

			if (innerAspect <= outerAspect()) {
				untrack(() => {
					// inner should fit vertically
					innerSize.y = fitter.calculatedSize.y
					innerSize.x = innerSize.y * innerAspect
					// fitted.size = [innerSize.y * innerAspect, fitter.calculatedSize.y]
				})
			} else {
				untrack(() => {
					// inner should fit horizontally
					innerSize.x = fitter.calculatedSize.x
					innerSize.y = innerSize.x / innerAspect
					// fitted.size = [fitter.calculatedSize.x, innerSize.x / innerAspect]
				})
			}
		})

		// let running = 0

		// Motor.addRenderTask((t, dt) => {
		// 	// requestAnimationFrame(function loop(t) {
		// 	// 	requestAnimationFrame(loop)

		// 	running += dt
		// 	if (running > 2000) return false

		// 	fitter.size.y = 100 * Math.abs(Math.sin(t * 0.001))
		// })

		///// ROTATION ON POINTER MOVE ///////////////////////////////////////////////

		const rotationAmount = 10
		const targetRotation = {
			x: 0,
			y: 0,
		}

		const setTargetRotation = event => {
			targetRotation.y = (event.clientX / scene.calculatedSize.x) * (rotationAmount * 2) - rotationAmount
			targetRotation.x = -((event.clientY / scene.calculatedSize.y) * (rotationAmount * 2) - rotationAmount)
		}

		// Rotate the image a little bit based on pointer position.
		scene.addEventListener('pointermove', setTargetRotation)
		scene.addEventListener('pointerdown', setTargetRotation)

		// Rotate the container towards the targetRotation over time to make it smooth.
		Motor.addRenderTask(() => {
			fitter.rotation.x += (targetRotation.x - fitter.rotation.x) * 0.05
			fitter.rotation.y += (targetRotation.y - fitter.rotation.y) * 0.05
		})

		autorun(() => (particleContainer.rotation = fitter.rotation))

		/////// CHANGE DEPTH ON SMALLER DEVICES /////////////////////////////////////////////////

		// const layers = Array.from(document.querySelectorAll('#fitted > lume-node'))

		// let smaller = false

		// window.addEventListener('resize', () => {
		// 	if (window.innerWidth < 1024) {
		// 		if (smaller) return
		// 		smaller = true

		// 		for (const layer of layers) {
		// 			layer.position.z *= 1.5
		// 		}
		// 	} else {
		// 		if (!smaller) return
		// 		smaller = false

		// 		for (const layer of layers) {
		// 			layer.position.z /= 1.5
		// 		}
		// 	}
		// })

		////// ADD PARTICLES /////////////////////////////////////////////////////////
		makeParticles()

		async function makeParticles() {
			const particleSpace = 1000
			const numberOfParticles = 300
			const starMarkup = await fetch('./star.svg').then(r => r.text())
			const starTmpl = document.createElement('template')
			starTmpl.innerHTML = starMarkup

			const particles = []

			for (let i = 0, l = numberOfParticles; i < l; i += 1) {
				const particle = document.createElement('lume-node')
				particle.classList.add('particle')
				particle.alignPoint = [0.5, 0.5]
				particle.mountPoint = [0.5, 0.5]
				// const r = 5 + Math.random() * 5
				const r = 10
				particle.size = [r, r]
				particle.opacity = 0.4

				particle.position.set(
					Math.random() * particleSpace - particleSpace / 2,
					Math.random() * particleSpace - particleSpace / 2,
					Math.random() * particleSpace - particleSpace / 2,
				)

				particle.append(starTmpl.content.firstChild.cloneNode(true))

				particleContainer.append(particle)
				particles.push(particle)
			}

			const initialOpacity = 0.7

			// Prior art: https://www.instructables.com/Realistic-Fire-Effect-with-Arduino-and-LEDs/
			const flickerFunction = () => {
				return
				for (let i = 0, l = numberOfParticles; i < l; i += 1) {
					const particle = particles[i]

					const flicker = (Math.random() - 1) * 0.4
					particle.opacity = initialOpacity + flicker
				}

				setTimeout(() => Motor.once(flickerFunction), Math.random() * 100)
			}

			Motor.once(flickerFunction)

			Motor.addRenderTask(() => {
				for (let i = 0, l = numberOfParticles; i < l; i += 1) {
					const particle = particles[i]

					particle.position.x += 0.5
					particle.position.y++

					if (particle.position.x > particleSpace / 2) {
						particle.position.x = -particleSpace / 2
					}
					if (particle.position.y > particleSpace / 2) {
						particle.position.y = -particleSpace / 2
					}
				}
			})
		}
	</script>
</body>
