<title>&lt;lume-orbit-controls&gt;</title>

<style>
	html,
	body {
		width: 100%;
		height: 100%;
		margin: 0;
		background: black;
		background: white;
	}

	lume-scene * {
		border: 30px solid teal;
	}
</style>

<script src="../dist/global.js"></script>

<script>
	{
		const {Behavior, PerspectiveCamera, THREE, Motor} = LUME

		// TODO: OrbitControls is instantiated and active, camera matrix is updated, but view doesn't update.
		class OrbitControls extends Behavior {
			get requiredElementType() {
				return PerspectiveCamera
			}

			connectedCallback() {
				console.log('hello!!!!!', this.element)

				this.controls = new THREE.OrbitControls(this.element.three, this.element.scene)

				this.controls.addEventListener('change', () => {
					this.element.three.updateWorldMatrix(true, false)
					this.element.three.updateProjectionMatrix()
					this.element.needsUpdate()
					this.element.scene.needsUpdate()

					// Still no update!
					console.log('orbit changed!')
					console.log(this.element.three.position)
				})
			}

			disconnectedCallback() {
				console.log('bye!!!!!', this.element)
			}
		}

		elementBehaviors.define('orbit-controls', OrbitControls)
	}
</script>

<lume-scene id="scene" perspective="800" webgl="false" enable-css="false">
	<lume-node id="lights" align="0.5 0.5 0.5" rotation="0 30 0">
		<lume-point-light color="yellow" position="500 0 0" intensity="1.2">
			<lume-sphere
				has="basic-material"
				color="yellow"
				opacity="0.5"
				mount-point="0.5 0.5 0.5"
				size="10 10 10"
				cast-shadow="false"
				receive-shadow="false"
			></lume-sphere>
		</lume-point-light>

		<lume-point-light color="deeppink" position="-500 0 0" intensity="1.2">
			<lume-sphere
				has="basic-material"
				color="deeppink"
				opacity="0.5"
				mount-point="0.5 0.5 0.5"
				size="10 10 10"
				cast-shadow="false"
				receive-shadow="false"
			></lume-sphere>
		</lume-point-light>

		<lume-point-light color="cyan" position="0 0 500" intensity="1.2">
			<lume-sphere
				has="basic-material"
				color="cyan"
				opacity="0.5"
				mount-point="0.5 0.5 0.5"
				size="10 10 10"
				cast-shadow="false"
				receive-shadow="false"
			></lume-sphere>
		</lume-point-light>

		<lume-point-light color="limegreen" position="0 0 -500" intensity="1.2">
			<lume-sphere
				has="basic-material"
				color="limegreen"
				opacity="0.5"
				mount-point="0.5 0.5 0.5"
				size="10 10 10"
				cast-shadow="false"
				receive-shadow="false"
			></lume-sphere>
		</lume-point-light>

		<lume-point-light color="white" position="0 -500 0" intensity="1.2">
			<lume-sphere
				has="basic-material"
				color="white"
				opacity="0.5"
				mount-point="0.5 0.5 0.5"
				size="10 10 10"
				cast-shadow="false"
				receive-shadow="false"
			></lume-sphere>
		</lume-point-light>

		<lume-point-light color="white" position="0 250 0" intensity="1.2">
			<lume-sphere
				has="basic-material"
				color="white"
				opacity="0.5"
				mount-point="0.5 0.5 0.5"
				size="10 10 10"
				cast-shadow="false"
				receive-shadow="false"
			></lume-sphere>
		</lume-point-light>
	</lume-node>

	<lume-box id="box" color="black" size="200 200 200" align="0.5 0.5 0.5" mount-point="0.5 0.5 0.5"></lume-box>

	<lume-plane
		color="black"
		size="2000 2000"
		rotation="90 0 0"
		align="0.5 0.5 0.5"
		mount-point="0.5 0.5 0.5"
		position="0 300 0"
	></lume-plane>

	<!-- This doesn't work right with ShadowDOM yet... -->
	<!-- <lume-rotate-controls id="rotate-controls">
		<lume-perspective-camera
			id="cam"
			Xhas="orbit-controls"
			active
			position="0 0 1000"
			align="0.5 0.5 0.5"
		></lume-perspective-camera>
	</lume-rotate-controls> -->

	<!-- ...But this works, without ShadowDOM. What's the difference? -->
	<lume-node id="controls" size="1 1 1" rotation="0 30 0" size-mode="proportional proportional proportional">
		<lume-node id="xRotator" size="1 1 1" rotation="40 0 0" size-mode="proportional proportional proportional">
			<lume-perspective-camera id="cam" active position="0 0 1000" align="0.5 0.5 0.5"></lume-perspective-camera>
		</lume-node>
	</lume-node>
</lume-scene>

<script>
	{
		LUME.useDefaultNames()

		const {Node, html, XYZSizeModeValues, XYZNonNegativeValues} = LUME

		class RotateControls extends Node {
			constructor(...args) {
				super(...args)

				this.sizeMode = new XYZSizeModeValues('proportional', 'proportional', 'proportional')
				this.size = new XYZNonNegativeValues(1, 1, 1)
			}

			__root = this.attachShadow({mode: 'open'})
			get root() {
				return this.__root
			}
			set root(v) {}

			template = () => html`
				<lume-node
					id="xRotator"
					ref=${e => (this.xRotator = e)}
					size-mode=${() => this.sizeMode}
					size=${() => this.size}
				>
					<slot></slot>
				</lume-node>
			`

			css = /*css*/ `
				* {
					border: 30px solid teal;
				}
			`

			connectedCallback() {
				super.connectedCallback()

				const scene = this.scene
				scene.style.setProperty('touch-action', 'none')

				// Add some interaction: drag to rotate the view:
				scene.addEventListener('pointerdown', () => {
					// Stop rotation if any.
					this.rotation = () => false

					let deltaX = 0
					let deltaY = 0

					const onMove = event => {
						deltaX = -event.movementY * 0.2
						this.xRotator.rotation.x += deltaX
						deltaY = -event.movementX * 0.2
						this.rotation.y += deltaY
					}

					scene.addEventListener('pointermove', onMove)

					scene.addEventListener(
						'pointerup',
						() => {
							// stop dragging
							scene.removeEventListener('pointermove', onMove)

							if (deltaX === 0 && deltaY === 0) return

							// slow the rotation down based on former drag speed
							this.xRotator.rotation = (x, y, z) => {
								deltaX = deltaX * 0.95

								// stop rotation once the delta is small enough that we
								// no longer notice the rotation.
								if (Math.abs(deltaX) < 0.01) return false

								return [x + deltaX, y, z]
							}
							this.rotation = (x, y, z) => {
								deltaY = deltaY * 0.95

								// stop rotation once the delta is small enough that we
								// no longer notice the rotation.
								if (Math.abs(deltaY) < 0.01) return false

								return [x, y + deltaY, z]
							}
						},
						{once: true},
					)
				})
			}
		}

		customElements.define('lume-rotate-controls', RotateControls)

		const minCamXRotation = -11
		const maxCamXRotation = 90

		// Add some interaction: drag to rotate the view:
		scene.addEventListener('pointerdown', () => {
			// Stop rotation if any.
			controls.rotation = () => false

			let deltaX = 0
			let deltaY = 0

			const onMove = event => {
				deltaX = event.movementY * 0.2
				xRotator.rotation.x = clamp(xRotator.rotation.x + deltaX, minCamXRotation, maxCamXRotation)
				deltaY = -event.movementX * 0.2
				controls.rotation.y += deltaY
			}

			scene.addEventListener('pointermove', onMove)

			scene.addEventListener(
				'pointerup',
				() => {
					// stop dragging
					scene.removeEventListener('pointermove', onMove)

					if (deltaX === 0 && deltaY === 0) return

					// slow the rotation down based on former drag speed
					xRotator.rotation = (x, y, z) => {
						deltaX = deltaX * 0.95

						// stop rotation once the delta is small enough that we
						// no longer notice the rotation.
						if (Math.abs(deltaX) < 0.01) return false

						return [clamp(x + deltaX, minCamXRotation, maxCamXRotation), y, z]
					}
					controls.rotation = (x, y, z) => {
						deltaY = deltaY * 0.95

						// stop rotation once the delta is small enough that we
						// no longer notice the rotation.
						if (Math.abs(deltaY) < 0.01) return false

						return [x, y + deltaY, z]
					}
				},
				{once: true},
			)
		})

		function clamp(n, min, max) {
			return Math.max(Math.min(n, max), min)
		}

		// box.rotation = (x, y, z) => [x, ++y, z]
		// cam.rotation = (x, y, z) => [x, y + 0.1, z]

		lights.rotation = (x, y, z) => [x, y + 0.2, z]
	}
</script>
